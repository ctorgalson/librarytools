<?php

/**
 * @file
 * Provides module logic for Library Tools module.
 */

// Include required files.
include_once 'librarytools.features.inc';
include_once "librarytools.admin.inc";
include_once "librarytools.library.inc";
include_once "librarytools.libraries.inc";
include_once "librarytools.theme.inc";
require_once DRUPAL_ROOT . base_path() . "sites/all/libraries/spyc/Spyc.php";

// Define constants.
define('LIBRARYTOOLS_LIBRARIES_OVERVIEW', 'admin/structure/libraries');
define('LIBRARYTOOLS_LIBRARIES_OVERVIEW_TAB', 'admin/structure/libraries/overview ');
define('LIBRARYTOOLS_LIBRARY_EXPORT_TAB', 'admin/structure/libraries/export');
define('LIBRARYTOOLS_LIBRARY_INFO', 'admin/structure/libraries/%librarytools_library_info/info');

/**
 * Export code formatting helper function for arrays.
 *
 * Returns an array + assignment formatted according the Drupal coding standard.
 * Works on nested arrays.
 *
 * @param array $array
 *   An array for output.
 * @param string $assignment
 *   An assignment of the general form "$a = " or "$b => ".
 * @param int $indent
 *   Indent level for the current level of array.
 * @param bool $top_level
 *   Whether or not this is the outermost level of the array. The value of this
 *   parameter determines whether or not the current pass will append a ";" to
 *   the generated code.
 *
 * @return string
 *   An array in string form, much like that produced by var_export(), but
 *   conforming to Drupal's coding standards.
 */
function _librarytools_format_array($array, $assignment, $indent = 0, $top_level = TRUE) {
  // Establish tab size, initial import. We're hardcoding the tab size because
  // we're only dealing with one set of coding standards.
  $tab = str_repeat(chr(32), 2);
  $indent_string = str_repeat($tab, $indent);

  // Output variables.
  $before = '';
  $output = '';
  $after = '';

  // We expect an array coming in.
  if (is_array($array)) {
    // Handle the outermost level.
    //
    // Add the semicolon if this is a top-level array.
    $end_character = $top_level ? ';' : '';

    // Create the assignment + operator.
    $assignment = !empty($assignment) ? $indent_string . $assignment : '';

    // The beginning of the array.
    $before_pattern = '%sarray(';
    $before = sprintf($before_pattern, $assignment);

    // The end of the array.
    $after_pattern = chr(10) . '%s)' . $end_character;
    $after = sprintf($after_pattern, $indent_string);

    // Everything from here on in needs a further indent.
    $indent++;

    // We'll need a common indent inside the loop.
    $indent_string = str_repeat($tab, $indent);

    // Loop through the rest of the incoming array.
    foreach ($array as $key => $value) {
      // Assignment patterns can be a) common, but b) vary according to type of
      // $key.
      $assignment_pattern = chr(10) . (is_numeric($key) ? '%s%s => ' : '%s"%s" => ');

      if (!is_array($value)) {
        // Here we have a relatively simple bit of string manipulation.
        $item_pattern = $assignment_pattern . '"%s",';
        $output .= sprintf($item_pattern, $indent_string, $key, $value);
      }
      else {
        // Otherwise, creating the assignment is still simple...
        $assignment = sprintf($assignment_pattern, $indent_string, $key);

        // But we need recursion to descend another level into the incoming
        // array.
        $item_pattern = '%s,';
        $value = _librarytools_format_array($value, $assignment, $indent++, $top_level = FALSE);
        $output .= sprintf($item_pattern, $value);

        // We've just finished the contents of an array, so we need to go back
        // one step in indentation.
        $indent--;
      }
    }
  }

  // Return whatever we've got to this point--first making a final pass to trim
  // EOL and in-parentheses whitespace (this is clearer than further compli-
  // cating the above logic).
  $replacement_patterns = array(
    // Finds any string â‰¥ 1 whitspace characters followed by a newline.
    '#\s+\n#',
    // Finds any string of whitepace characters (including newlines) enclosed by
    // parentheses.
    '#\(\s+\)#m'
  );

  $replacement_strings = array(
    chr(10),
    '()',
  );

  return preg_replace($replacement_patterns, $replacement_strings, $before . $output . $after);
}

/**
 * Implements hook_form_alter().
 */
function librarytools_form_alter(&$form, &$form_state, $form_id) {
  switch ($form_id) {
    case 'eck__entity__form_edit_librarytools_core_library_librarytools_core_library':
      $form['#validate'][] = 'librarytools_core_library_validate';
      break;
  }
}

/**
 * Callback form validation for core library entity creation form.
 */
function librarytools_core_library_validate(&$form, &$form_state) {
}

/**
 * Callback for admin/structure/libraries menu hook.
 */
function librarytools_libraries_summary() {
  $output = '';

  if (module_exists('libraries')) {
    $output .= '<h2>' . t('Available <code>hook_libraries_info()</code> libraries') . '</h2>';
    $output .= _librarytools_hook_libraries_info_libraries();
  }
  $output .= '<h2>' . t('Available <code>hook_library()</code> libraries') . '</h2>';
  $output .= _librarytools_hook_library_libraries();

  return $output;
}

/**
 * Callback for admin/structure/libraries/%/info menu hook.
 */
function librarytools_library_info($library) {
  // Page title.
  reset($library);
  $library_name = key($library);
  drupal_set_title(t('Library info: @library_name', array('@library_name' => $library_name)));

  // Content.
  $content = !empty($library) ? kpr($library, TRUE) : t('No library name "@library" could be found.');

  return $content;
}

/**
 * Autoloader function for librarytools_library_info() function.
 */
function librarytools_library_info_load($library_name) {
  // Sanitize the input.
  $safe_library_name = check_plain($library_name);

  // (Attempt to) explode the input.
  $library_meta = explode(':', $safe_library_name);
  $argument_count = count($library_meta);

  // Attempt to load library by number of args and module existence.
  if ($argument_count > 1) {
    $library = drupal_get_library($library_meta[0], $library_meta[1]);
    $library_name = $library['title'];
  }
  elseif (module_exists('libraries') && $argument_count == 1) {
    $library = libraries_load($library_meta[0]);
    $library_name = $library['name'];
  }

  return isset($library) ? array($library_name => $library) : FALSE;
}

/**
 * Implements hook_menu().
 */
function librarytools_menu() {
  $items = array();

  // Library information page.
  $items[LIBRARYTOOLS_LIBRARIES_OVERVIEW] = array(
    'access arguments' => array('administer librarytools'),
    'description' => 'The libraries in the following table are available for use on this site',
    'page callback' => 'librarytools_libraries_summary',
    'title' => 'Library Tools',
    'type' => MENU_NORMAL_ITEM,
  );

  // Default tab.
  $items[LIBRARYTOOLS_LIBRARIES_OVERVIEW_TAB] = array(
    'title' => 'Available Libraries',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );

  $items[LIBRARYTOOLS_LIBRARY_EXPORT_TAB] = array(
    'access arguments' => array('administer librarytools'),
    'page arguments' => array('librarytools_library_export'),
    'page callback' => 'drupal_get_form',
    'title' => 'Library Export',
    'type' => MENU_LOCAL_TASK,
  );

  // Individual library information pages.
  $items[LIBRARYTOOLS_LIBRARY_INFO] = array(
    'access arguments' => array('administer librarytools'),
    'page arguments' => array(3),
    'page callback' => 'librarytools_library_info',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Implements template_preprocess_entity().
 *
 * @todo
 *  - Transform yaml
 */
function librarytools_preprocess_entity(&$variables) {
  switch ($variables['entity_type']) {
    case 'librarytools_core_library':
      // Get a wrapper for the entity.
      $library_wrapper = $variables['elements']['#entity']->wrapper();

      // Grab a bunch of properties.
      $machine_name = $library_wrapper->field_core_machine_name->value();
      $title = $library_wrapper->label();
      $website = $library_wrapper->field_core_website->value();
      $version = $library_wrapper->field_core_version->value();
      $js = spyc_load($library_wrapper->field_core_js->value());
      $css = spyc_load($library_wrapper->field_core_css->value());
      $dependencies = spyc_load($library_wrapper->field_core_dependencies->value());

      // Define the library.
      $library = array(
        'title' => $title,
        'website' => $website['display_url'],
        'version' => $version,
        'js' => $js,
        'css' => $css,
        'dependencies' => $dependencies,
      );

      // Define the basic structure for the on-page output.
      $library_pattern = <<<EOT
/**
 * Implements hook_library().
 */
function MODULENAME_library() {
  // Create libraries array.
  \$libraries = array();

  // Define library.
%s

  // Return libraries array.
  return \$libraries;
}
EOT;

      // We need an assignment to generate the array.
      $assignment = sprintf('$libraries[\'%s\'] = ', $machine_name);

      // Generate the array.
      $library_array_string = _librarytools_format_array($library, $assignment, 1);

      // Produce the renderable array for the page.
      $variables['export'] = array(
        '#collapsed' => TRUE,
        '#collapsible' => TRUE,
        '#title' => t('Exportable code'),
        '#type' => 'fieldset',
        'content' => array(
          '#type' => 'textarea',
          '#value' => sprintf($library_pattern, $library_array_string),
        ),
      );
      break;
  }
}

/**
 * Implements template_preprocess_field().
 */
function librarytools_preprocess_field(&$variables) {
  switch ($variables['element']['#bundle']) {
    case 'librarytools_core_library':
      if ($variables['element']['#field_type'] === 'text_long') {
        $variables['theme_hook_suggestions'][] = 'field__librarytools__text_long';
      }
      break;
  }
}

/**
 * Implements template_preprocess_page().
 */
function librarytools_preprocess_page(&$variables) {
  if (strpos('admin/structure/libraries', drupal_get_path_alias()) === 0) {
    drupal_add_css(drupal_get_path('module', 'librarytools') . '/css/librarytools.admin.css');
  }
}

/**
 * Implmenents hook_theme().
 */
function librarytools_theme() {
  $path_to_module = drupal_get_path('module', 'librarytools') . '/templates';

  $items = array(
    'librarytools_dependencies' => array(
      'variables' => array(
        'dependencies',
      ),
    ),
    'librarytools_dependency' => array(
      'variables' => array(
        'dependency_name' => NULL,
        'class_name' => NULL,
        'status' => NULL,
      ),
    ),
    'librarytools_title' => array(
      'variables' => array(
        'title' => NULL,
      ),
    ),
    // Entity.
    'librarytools_core_library' => array(
      'variables' => array(
        array(
          'element' => NULL,
        ),
      ),
      'template' => 'librarytools--library',
      'path' => $path_to_module,
    ),
  );

  // Textarea fields in entity.
  $field__librarytools__text_long = isset($existing['field']) ? $existing['field'] : array();
  $field__librarytools__text_long['path'] = $path_to_module;
  $field__librarytools__text_long['template'] = 'field--librarytools--text-long';

  $items['field__librarytools__text_long'] = $field__librarytools__text_long;

  return $items;
}
